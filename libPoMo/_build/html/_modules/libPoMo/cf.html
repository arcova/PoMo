

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>libPoMo.cf &mdash; libPoMo 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="libPoMo 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">libPoMo 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for libPoMo.cf</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;libPomo.countsformat</span>
<span class="sd">----------------------------------------------------------------------</span>

<span class="sd">This model provides functions to read, write and access files that are</span>
<span class="sd">in counts format.</span>

<span class="sd">The Counts Format</span>
<span class="sd">=================</span>
<span class="sd">This file format is used by PoMo and lists the base</span>
<span class="sd">counts for every position. It contains:</span>

<span class="sd">1 headerline with tab separated sequence names</span>
<span class="sd">N lines with counts of A, C, G and T bases at position n</span>

<span class="sd">CHROM \t Pos   \t Sheep   \t BlackSheep \t RedSheep \t Wolf    \t RedWolf</span>
<span class="sd">chrA  \t s     \t 0,0,1,0 \t 0,0,1,0    \t 0,0,1,0  \t 0,0,5,0 \t 0,0,0,1</span>
<span class="sd">chrA  \t s + 1 \t 0,0,0,1 \t 0,0,0,1    \t 0,0,0,1  \t 0,0,0,5 \t 0,0,0,1</span>
<span class="sd">.</span>
<span class="sd">.</span>
<span class="sd">.</span>
<span class="sd">chrF  \t 8373  \t 0,0,0,1 \t 1,0,0,0    \t 0,1,0,0  \t 0,1,4,0 \t 0,0,1,0</span>
<span class="sd">.</span>
<span class="sd">.</span>
<span class="sd">.</span>
<span class="sd">chrE  \t end   \t 0,0,0,1 \t 0,1,0,0    \t 0,1,0,0  \t 0,5,0,0 \t 0,0,1,0</span>

<span class="sd">Objects</span>
<span class="sd">=======</span>
<span class="sd">Classes:</span>
<span class="sd">- `CFWriter`, write a counts format file</span>

<span class="sd">Exception Classes:</span>
<span class="sd">- `CountsFormatWriterError`</span>

<span class="sd">Functions:</span>
<span class="sd">- `save_as_vc()`: Deprecated. Save given sequences to a counts format</span>
<span class="sd">  file.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s">&#39;restructuredtext&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">pysam</span> <span class="kn">as</span> <span class="nn">ps</span>

<span class="kn">import</span> <span class="nn">libPoMo.seqbase</span> <span class="kn">as</span> <span class="nn">sb</span>
<span class="kn">import</span> <span class="nn">libPoMo.vcf</span> <span class="kn">as</span> <span class="nn">vcf</span>
<span class="kn">import</span> <span class="nn">libPoMo.fasta</span> <span class="kn">as</span> <span class="nn">fa</span>

<span class="n">dna</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;t&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>


<div class="viewcode-block" id="CountsFormatWriterError"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CountsFormatWriterError">[docs]</a><span class="k">class</span> <span class="nc">CountsFormatWriterError</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General `CFWriter` object error.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="CFWriter"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter">[docs]</a><span class="k">class</span> <span class="nc">CFWriter</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Write a counts format file.</span>

<span class="sd">    Save information that is needed to write a CF file and use this</span>
<span class="sd">    information to write a CF file.</span>

<span class="sd">    Initialize with a reference fasta file name, a list of vcf file</span>
<span class="sd">    names and an output file name (cf. `self.__init__`):</span>
<span class="sd">    .. code:: python</span>
<span class="sd">       CFWriter(&quot;refFasta&quot;, [vcfFileNames], &quot;output&quot;)</span>

<span class="sd">    Write a header line to output:</span>
<span class="sd">    .. code:: python</span>
<span class="sd">       self.write_HLn()</span>

<span class="sd">    Write lines in counts format from position start to end on</span>
<span class="sd">    chromosome chrom to output:</span>
<span class="sd">    .. code:: python</span>
<span class="sd">       rg = sb.Region(&quot;chrom&quot;, start, end)</span>
<span class="sd">       self.write_Rn(rg)</span>

<span class="sd">    Remember to close the attached file objectsL</span>
<span class="sd">    .. code:: python</span>
<span class="sd">       self.close()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refFileName</span><span class="p">,</span> <span class="n">vcfFileNameL</span><span class="p">,</span> <span class="n">outFileName</span><span class="p">,</span>
                 <span class="n">verb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mergeL</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nameL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Passed variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refFN</span> <span class="o">=</span> <span class="n">refFileName</span>
        <span class="sd">&quot;&quot;&quot;Reference fasta file name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span> <span class="o">=</span> <span class="n">vcfFileNameL</span>
        <span class="sd">&quot;&quot;&quot;List with VCF file names.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFN</span> <span class="o">=</span> <span class="n">outFileName</span>
        <span class="sd">&quot;&quot;&quot;CF output file name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">verb</span>
        <span class="sd">&quot;&quot;&quot;Verbosity level.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="o">=</span> <span class="n">mergeL</span>
        <span class="sd">&quot;&quot;&quot;A list of truth values.  If `mL[i]` is True, all individuals of</span>
<span class="sd">        `self.vcfL[i]` are treated as one population orspecies</span>
<span class="sd">        independent of their name.  The respective counts are summed</span>
<span class="sd">        up.  If `self.nL[i]` is given, the name of the summed sequence</span>
<span class="sd">        will be `self.nL[i]`.  If not, the name of the first</span>
<span class="sd">        individual in `vcfL[i]` will be used.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="n">nameL</span>
        <span class="sd">&quot;&quot;&quot;A list of names. Cf. `self.mL`.&quot;&quot;&quot;</span>
        <span class="c"># Variables that are filled during initialization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nV</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Number of vcf files.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;List with `pysam.Tabixfile` objects.  Filled by</span>
<span class="sd">        `self.init_vcfTfL()` during initialization.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refFaStr</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">init_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refFN</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;`FaStream` object of the reference genome. This might be changed to</span>
<span class="sd">        an `MFaStream` object in the future.&quot;&quot;&quot;</span>  <span class="c"># TODO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot;File object of the outfile. Filled by `self.__init_outFO` during</span>
<span class="sd">        initialization.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;List with allele or base counts.  The alleles of individuals from</span>
<span class="sd">        the same population are summed up.  Hence, `self.cD[p]` gives</span>
<span class="sd">        the base counts of population `p` in the form: [0, 0, 0, 0].</span>
<span class="sd">        Population `p` does not need to be the one from `self.vcfL[p]`</span>
<span class="sd">        because several populations might be present in one vcf file.</span>
<span class="sd">        `self.assM` connects the individual j from `self.vcfL[i]` such</span>
<span class="sd">        that `self.assM[i][j]` is `p`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot;Current chromosome. Set and updated by `self.fill_cD`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="sd">&quot;&quot;&quot;Current position on chromosome. Set and updated by `self.fill_cD&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;Matrix with individuals from vcf files. `self.indM[i]` is the list</span>
<span class="sd">        of individuals found in `self.vcfL[i]`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;List with number of individuals in `self.vcfL[i]`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;Assignment matrix that connects the individuals from the vcf files</span>
<span class="sd">        to the correct `self.cd` index. Cf. `self.cD`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;Number of different populations in count format output file</span>
<span class="sd">        (e.g. number of populations). Filled by `self.init_assM()`</span>
<span class="sd">        during initialization.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="sd">&quot;&quot;&quot;Ploidy of individuals in vcf files. This has to be set to the</span>
<span class="sd">        correct value for non-diploids.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__splitCh</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span>

        <span class="sd">&quot;&quot;&quot;Character that is used to split the individual names.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_vcfTfL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_outFO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_indM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nIndL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_assM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init_vcfTfL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open vcf files given in `self.vcfL`.</span>

<span class="sd">        Tabix index files need to be provided. They can be created</span>
<span class="sd">        from the terminal with $(tabix -p vcf &quot;vcf-file.vcf.gz&quot;). The</span>
<span class="sd">        tabix file objects are stored in `self.vcfTfL`. They need to</span>
<span class="sd">        be closed with `self.close()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">Tabixfile</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init_outFO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open `self.outFN`.</span>

<span class="sd">        If the file name ends with &quot;gz&quot;, the outfile will be</span>
<span class="sd">        compressed and is opened with gzip.open().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="s">&quot;gz&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;wt&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_indM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Extract individuals from the vcf files.&quot;&quot;&quot;</span>
        <span class="c"># Get individuals from the vcf files.</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">tf</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="n">hLn</span> <span class="o">=</span> <span class="n">ln</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">vcf</span><span class="o">.</span><span class="n">get_indiv_from_field_header</span><span class="p">(</span><span class="n">hLn</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&quot;utf-8&quot;</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__init_nIndL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count individuals in each vcf file.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">indL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indL</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init_assM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill assignment matrix `self.assM`.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">collapse_and_append</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dN</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Collapse individual names of `self.vcfL[n]`.</span>

<span class="sd">            Appends the collapsed individual names of `self.vcfL[n]`</span>
<span class="sd">            to `self.assM`.</span>

<span class="sd">            - `dN`: Offset in assL.</span>
<span class="sd">            Returns new offset.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
            <span class="n">aL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cL</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ddN</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">cL</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">index</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">ddN</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">ddN</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dN</span> <span class="o">+</span> <span class="n">ddN</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;Merge list is not &quot;</span> <span class="o">+</span>
                                                  <span class="s">&quot;a list of boolean values.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;`mergeL` is not valid.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dI</span> <span class="o">+</span> <span class="mi">1</span>
                
    <span class="k">def</span> <span class="nf">__init_nL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill `self.nL`.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s">&quot;`nameL` is not valid.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the list with counts data.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__snp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate SNPs in region `rg` out of `self.vcfL`.</span>

<span class="sd">        Generator that returns the next SNP in region `rg`</span>
<span class="sd">        (cf. `seqbase.Region`) as a `NucBase` object.  To loop over</span>
<span class="sd">        all SNPs in region `rg`:</span>

<span class="sd">        &gt;&gt;&gt; rg = sb.Region(&quot;chr1&quot;, 500000, 1000000)</span>
<span class="sd">        &gt;&gt;&gt; for s in self.snp(rg):</span>
<span class="sd">        ....:   s.print_info()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">snpIterL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="n">snpIterL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">reference</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                                 <span class="n">start</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                       <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">snpL</span> <span class="o">==</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
                   <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">minPos</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">minI</span><span class="p">,</span> <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">minI</span><span class="p">]),</span>
                                                        <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__purge_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fill_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iL</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">snpL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill `self.cF`.</span>

<span class="sd">        Fill `self.cF` with data from reference at chromosome `chrom`</span>
<span class="sd">        and position `pos`. Possible SNPs in `slef.vcfL` at this</span>
<span class="sd">        position are considered.</span>

<span class="sd">        - `iL`: List with vcf indices of the SNPs in `snpL`, must be sorted.</span>
<span class="sd">        - `snpL`: List with `NucBase` SNPs at this position. None, if</span>
<span class="sd">          there is no SNP.</span>

<span class="sd">        Raises the excpetion `sb.NotAValidRefBase` if the reference</span>
<span class="sd">        base is not valid (e.g. N).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_refBase</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Get reference base on `chrom` at `pos`.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">refFaStr</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refFaStr</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;Chromosome name invalid.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__purge_cD</span><span class="p">()</span>
        <span class="n">refBase</span> <span class="o">=</span> <span class="n">get_refBase</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">refBase</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">()</span>
        <span class="c"># If there are no SNPS, fill `self.cD` with data from reference.</span>
        <span class="k">if</span> <span class="n">iL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">snpL</span><span class="p">)):</span>
            <span class="c"># Else, only fill `self.cD` where the individual has no SNP</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iL</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="c"># Now traverse the SNPs</span>
            <span class="k">for</span> <span class="n">sI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)):</span>
                <span class="n">altBases</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_alt_base_list</span><span class="p">()</span>
                <span class="n">spData</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_speciesData</span><span class="p">()</span>
                <span class="n">vI</span> <span class="o">=</span> <span class="n">iL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span>
                <span class="c"># Loop over individuals.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spData</span><span class="p">)):</span>
                    <span class="c"># ipdb.set_trace()</span>
                <span class="c"># Loop over chromatides (e.g. diploid).</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">elif</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">bI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">altBases</span><span class="p">[</span><span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">bI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;SNP information is not correct.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string with a line in counts format. Positional information</span>
<span class="sd">        is written 1-based.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stringL</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">:</span>
            <span class="n">stringL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stringL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string containing the headerline in counts format.&quot;&quot;&quot;</span>
        <span class="n">strL</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;CHROM&quot;</span><span class="p">,</span> <span class="s">&quot;POS&quot;</span><span class="p">]</span>
        <span class="n">strL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__write_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a line in counts format to `self.outFN`.&quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_Ln</span><span class="p">(),</span> <span class="nb">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>

<div class="viewcode-block" id="CFWriter.write_HLn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_HLn">[docs]</a>    <span class="k">def</span> <span class="nf">write_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the counts format header line to `self.outFN`.&quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_HLn</span><span class="p">(),</span> <span class="nb">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="CFWriter.write_Rn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_Rn">[docs]</a>    <span class="k">def</span> <span class="nf">write_Rn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write lines in counts format to `self.outFN`.</span>

<span class="sd">        - `rg`: `Region` object that determines the region that is</span>
<span class="sd">          covered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snpsG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__snp</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">nSNP</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rg</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">snpL</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">iL</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">nI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nSNP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nSNP</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">iL</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nSNP</span><span class="p">)</span>
                    <span class="n">iL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nI</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="n">nI</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="n">nSNP</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">rg</span><span class="o">.</span><span class="n">chrom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fill_cD</span><span class="p">(</span><span class="n">iL</span><span class="p">,</span> <span class="n">snpL</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__write_Ln</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="CFWriter.close"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close fileobjects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="c">###############################################################################</span>
<span class="c">## Deprecated stuff follows.</span>

</div></div>
<div class="viewcode-block" id="get_cf_headerline"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.get_cf_headerline">[docs]</a><span class="k">def</span> <span class="nf">get_cf_headerline</span><span class="p">(</span><span class="n">species</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a string containing the headerline in counts format.&quot;&quot;&quot;</span>
    <span class="n">stringL</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&quot;CHROM&quot;</span><span class="p">,</span> <span class="s">&quot;POS&quot;</span><span class="p">]]</span>
    <span class="n">stringL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">stringL</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="collapse"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.collapse">[docs]</a><span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">speciesL</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Collapse the species names.</span>

<span class="sd">    Collapse the species names using the naming rules given in</span>
<span class="sd">    save_as_countsformat. Returns a dictionary with collapsed</span>
<span class="sd">    species names as keys and an assignment list.</span>

<span class="sd">    - `merge`: if set to True, all species/individuals will be</span>
<span class="sd">    collapsed to a single one with name `name` (if `name` is</span>
<span class="sd">    given).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">speciesL</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">merge</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">speciesL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">assList</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
        <span class="n">collapsedSp</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">assList</span> <span class="o">=</span> <span class="p">[</span><span class="n">speciesL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span>
        <span class="n">collapsedSp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">assList</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">collapsedSp</span><span class="p">,</span> <span class="n">assList</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="find_next_SNP_pos"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.find_next_SNP_pos">[docs]</a><span class="k">def</span> <span class="nf">find_next_SNP_pos</span><span class="p">(</span><span class="n">nSNPChromL</span><span class="p">,</span> <span class="n">nSNPPosL</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the position of next SNP.</span>

<span class="sd">    Return the position of the next SNP in `ref` and a list of</span>
<span class="sd">    indices of these SNPs in `nSNPChromL` and `nSNPPosL`. If no</span>
<span class="sd">    next SNP is found on this sequence (this might happen if all</span>
<span class="sd">    next SNPs are on the next chromosome) a ValueError is raised.</span>

<span class="sd">    - `nSNPChromL`: List with chromosome names of the next SNPs of</span>
<span class="sd">                    the `vcfStrL`.</span>
<span class="sd">    - `nSNPPosL`: List with positions of the next SNPs of the</span>
<span class="sd">                  `vcfStrL`.</span>
<span class="sd">    - `ref`: Seq object of the sequence of the reference.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">indL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">posL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nSNPChromL</span><span class="p">)):</span>
        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">nSNPChromL</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">posL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nSNPPosL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">indL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">posL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">npPosL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posL</span><span class="p">)</span>
        <span class="n">minIndL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">npPosL</span> <span class="o">==</span> <span class="n">npPosL</span><span class="o">.</span><span class="n">min</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">fIndL</span> <span class="o">=</span> <span class="p">[</span><span class="n">indL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minIndL</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">posL</span><span class="p">[</span><span class="n">minIndL</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">fIndL</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No next SNP found in `ref`.&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="fill_species_dict_ref"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.fill_species_dict_ref">[docs]</a><span class="k">def</span> <span class="nf">fill_species_dict_ref</span><span class="p">(</span><span class="n">spDi</span><span class="p">,</span> <span class="n">assL</span><span class="p">,</span> <span class="n">refBase</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fills the species dictionary if no SNP is present.&quot;&quot;&quot;</span>
    <span class="c"># reset species dictionary to 0 counts per base</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">spDi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">spDi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c"># if no altBase is given, count species</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">refBase</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c"># Base is not valid (reference is masked on this position).</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">assL</span><span class="p">:</span>
        <span class="n">spDi</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ploidy</span>
    <span class="k">return</span>

</div>
<div class="viewcode-block" id="fill_species_dict_alt"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.fill_species_dict_alt">[docs]</a><span class="k">def</span> <span class="nf">fill_species_dict_alt</span><span class="p">(</span><span class="n">spDi</span><span class="p">,</span> <span class="n">assL</span><span class="p">,</span> <span class="n">refBase</span><span class="p">,</span> <span class="n">altBases</span><span class="p">,</span> <span class="n">spData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill the species dictionary when a SNP is present.</span>

<span class="sd">    Raise `SequenceDataError`, if `spDi` could not be filled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># reset species dictionary to 0 counts per base</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">spDi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">spDi</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">altBases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
       <span class="ow">and</span> <span class="p">(</span><span class="n">spData</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">refBase</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">altBases</span><span class="p">:</span>
            <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="c"># loop over species</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spData</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spData</span><span class="p">)):</span>
            <span class="c"># loop over chromatides (e.g. diploid)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">bI</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">bases</span><span class="p">[</span><span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]]]</span>
                    <span class="n">spDi</span><span class="p">[</span><span class="n">assL</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">bI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>
    <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;Could not fill species dictionary.&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_counts_line"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.get_counts_line">[docs]</a><span class="k">def</span> <span class="nf">get_counts_line</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">spDi</span><span class="p">,</span> <span class="n">speciesL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return line string in counts format.&quot;&quot;&quot;</span>
    <span class="n">stringL</span> <span class="o">=</span> <span class="p">[</span><span class="n">chrom</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spDi</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">speciesL</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="n">stringL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">spDi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">speciesL</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])))</span>
    <span class="k">return</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stringL</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="save_as_cf"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.save_as_cf">[docs]</a><span class="k">def</span> <span class="nf">save_as_cf</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">,</span> <span class="n">refFaStr</span><span class="p">,</span> <span class="n">CFFileName</span><span class="p">,</span> <span class="n">verb</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">mergeL</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nameL</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Save the given sequence in counts format.</span>

<span class="sd">    This function saves the SNPs from `vcfStrL`, a given list of</span>
<span class="sd">    `VCFStream` (variant call format sequence stream) objects in</span>
<span class="sd">    counts format to the file `CFFileName`.  The reference genome</span>
<span class="sd">    `refFaStr`, to which `VCFSeqStr` is compared to, needs to be</span>
<span class="sd">    passed as an `FaStream` object.</span>

<span class="sd">    The name of all streams in `vcfStrL` should be the same as the</span>
<span class="sd">    name of `faRef`.  The names of the sequences in the reference</span>
<span class="sd">    should be the names of the chromosomes found in the `vcfStr`</span>
<span class="sd">    object, otherwise we do not know where to compare the sequences</span>
<span class="sd">    to.  They must also be in the same order!</span>

<span class="sd">    Individuals with the same name and suffix &quot;_n&quot;, where n is a</span>
<span class="sd">    number, will be saved in one column without the suffix.</span>

<span class="sd">    - `vcfStrL`: List with VCF Streams containing SNPs.</span>
<span class="sd">    - `refFaStr`: Reference fasta sequence stream object.</span>
<span class="sd">    - `CFFileName`: Name of output file (counts format).</span>
<span class="sd">    - `verb`: If `verb` is set to True, additional information is</span>
<span class="sd">              printed to the output file.</span>
<span class="sd">    - `mergeL`: A list of truth values. If `mergeL[i]` is True, all</span>
<span class="sd">                individuals of `vcfStrL[i]` are treated as one species</span>
<span class="sd">                independent of their name. The respective counts are</span>
<span class="sd">                summed up.  If `nameL[i]` is given, the name of the</span>
<span class="sd">                summed sequence will be `nameL[i]`. If not, the name of</span>
<span class="sd">                the first individual in `vcfStrL[i]` will be used.</span>
<span class="sd">    - `nameL`: A list of names. Cf. `mergeL`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lVcfStrL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">refFaStr</span><span class="p">,</span> <span class="n">fa</span><span class="o">.</span><span class="n">FaStream</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;`faRef` is not an FaStream object.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vcf</span><span class="o">.</span><span class="n">VCFStream</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;`vcfStr` &quot;</span> <span class="o">+</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="s">&quot; is not a VCFStream object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">refFaStr</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;VCF sequence name &quot;</span> <span class="o">+</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                       <span class="s">&quot; and reference name &quot;</span> <span class="o">+</span> <span class="n">refFaStr</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                                       <span class="s">&quot; do not match.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nSpecies</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s">&quot;`VCFSeq` has no saved data.&quot;</span><span class="p">)</span>

    <span class="c"># Set mergeL and nameL if they are not given.</span>
    <span class="k">if</span> <span class="n">mergeL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mergeL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
            <span class="n">mergeL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nameL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">nameL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
            <span class="n">nameL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="c"># ploidy = number of haploid sets given in the VCF file</span>
    <span class="c"># allSpeciesL = list of vcfStr species</span>
    <span class="c"># assL = assignment list; allSpeciesL[i]=Wolf_n =&gt; assL[i]=Wolf</span>
    <span class="c"># collSpeciesL = collapsed species list (_n removed)</span>
    <span class="c"># spDiL = list of dictionaries with speciesL as keys and list of counts</span>
    <span class="c"># hence, spDi[assL[i]] is the list of counts for Wolf</span>
    <span class="n">ploidy</span> <span class="o">=</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">set_ploidy</span><span class="p">()</span>
    <span class="n">allSpeciesL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">collSpeciesL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">assL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spDiL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
        <span class="n">allSpeciesL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">speciesL</span><span class="p">)</span>
        <span class="p">(</span><span class="n">collSpecies</span><span class="p">,</span> <span class="n">ass</span><span class="p">)</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">speciesL</span><span class="p">,</span> <span class="n">mergeL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nameL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">collSpeciesL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collSpecies</span><span class="p">)</span>
        <span class="n">assL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ass</span><span class="p">)</span>
        <span class="n">spDiL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">collSpecies</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">CFFileName</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="s">&quot;gz&quot;</span><span class="p">:</span>
        <span class="n">fo</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">CFFileName</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;wt&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">CFFileName</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verb</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;#Sequence name =&quot;</span><span class="p">,</span> <span class="n">refFaStr</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">get_cf_headerline</span><span class="p">(</span><span class="n">collSpeciesL</span><span class="p">),</span> <span class="nb">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
    <span class="c"># get chromosomes and positions of next SNPs from the vcfStrL</span>
    <span class="n">nSNPChromL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nSNPPosL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
        <span class="n">nSNPChromL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">nSNPPosL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcfStrL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Loop over sequences (chromosomes) in refFaStr.</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Initialize the saved old position of the previous SNP</span>
        <span class="c"># and the sequence of the reference genome.</span>
        <span class="n">oldPos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">refFaStr</span><span class="o">.</span><span class="n">seq</span>
        <span class="k">if</span> <span class="n">verb</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;#Chromosome name =&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
        <span class="c"># Find next SNP position and the corresponding indices</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">nSNPPos</span><span class="p">,</span> <span class="n">nSNPIndL</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_next_SNP_pos</span><span class="p">(</span><span class="n">nSNPChromL</span><span class="p">,</span>
                                                    <span class="n">nSNPPosL</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">nSNPPos</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">dataLen</span>
            <span class="n">nSNPIndL</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Loop over positions in sequence `ref` of the reference genome.</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Loop from previous SNP to one position before this one.</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oldPos</span><span class="p">,</span> <span class="n">nSNPPos</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dna</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c"># Base is not valid (reference is masked on this position).</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
                    <span class="n">fill_species_dict_ref</span><span class="p">(</span><span class="n">spDiL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">ploidy</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">get_counts_line</span><span class="p">(</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">spDiL</span><span class="p">,</span> <span class="n">collSpeciesL</span><span class="p">),</span> <span class="nb">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
            <span class="c"># Process the SNP at position pos on chromosome ref.</span>
            <span class="k">if</span> <span class="n">nSNPIndL</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># There is no more SNP on this chromosome.</span>
                <span class="k">break</span>
            <span class="c"># Set spDiL to reference</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lVcfStrL</span><span class="p">):</span>
                <span class="n">fill_species_dict_ref</span><span class="p">(</span><span class="n">spDiL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assL</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="n">ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">nSNPPos</span><span class="p">],</span> <span class="n">ploidy</span><span class="p">)</span>
            <span class="c"># Loop over SNPs at position nSNPPos.</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nSNPIndL</span><span class="p">)):</span>
                <span class="n">altBases</span> <span class="o">=</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_alt_base_list</span><span class="p">()</span>
                <span class="n">spData</span> <span class="o">=</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_speciesData</span><span class="p">()</span>
                <span class="n">fill_species_dict_alt</span><span class="p">(</span><span class="n">spDiL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]],</span> <span class="n">assL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]],</span>
                                      <span class="n">ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">nSNPPos</span><span class="p">],</span> <span class="n">altBases</span><span class="p">,</span>
                                      <span class="n">spData</span><span class="p">)</span>
                <span class="c"># Read next SNP.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vcfStrL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span><span class="o">.</span><span class="n">read_next_base</span><span class="p">()</span>
                    <span class="n">nSNPChromL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span>\
                        <span class="o">=</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">chrom</span>
                    <span class="n">nSNPPosL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="n">vcfStrL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c"># VCFStream ends here.</span>
                    <span class="n">nSNPChromL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">nSNPPosL</span><span class="p">[</span><span class="n">nSNPIndL</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c"># Save old SNP position.</span>
            <span class="n">oldPos</span> <span class="o">=</span> <span class="n">nSNPPos</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">print</span><span class="p">(</span><span class="n">get_counts_line</span><span class="p">(</span>
                <span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">nSNPPos</span><span class="p">,</span> <span class="n">spDiL</span><span class="p">,</span> <span class="n">collSpeciesL</span><span class="p">),</span> <span class="nb">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
            <span class="c"># Find next SNP position and the corresponding indices</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">nSNPPos</span><span class="p">,</span> <span class="n">nSNPIndL</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_next_SNP_pos</span><span class="p">(</span><span class="n">nSNPChromL</span><span class="p">,</span>
                                                        <span class="n">nSNPPosL</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">nSNPPos</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">dataLen</span>
                <span class="n">nSNPIndL</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Read next sequence in reference and break if none is found.</span>
        <span class="k">if</span> <span class="n">refFaStr</span><span class="o">.</span><span class="n">read_next_seq</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">libPoMo 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Dominik Schrempf.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>